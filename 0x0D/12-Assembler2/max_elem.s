.data
printf_format:
        .string "%d\n"
 
array:
        .long 100, 15, 148, 12, 151, 3, 72
array_end:
 
.text
.globl main
main:
        movl  $0, %eax          /* в %eax будет храниться результат;
                                   в начале наибольшее значение - 0  */
        movl  $array, %ebx      /* в %ebx находится адрес текущего 
                                   элемента массива                  */
 
loop_start:                     /* начало цикла                      */
        cmpl  %eax, (%ebx)      /* сравнить текущий элемент массива с 
                                   текущим наибольшим значением из %eax
                                                                     */
        jbe   less              /* если текущий элемент массива меньше 
                                   или равен наибольшему, пропустить 
                                   следующий код                     */
        movl  (%ebx), %eax      /* а вот если элемент массива 
                                   превосходит наибольший, значит, его 
                                   значение и есть новый максимум    */
less:
        addl  $4, %ebx          /* увеличить %ebx на размер одного 
                                   элемента массива, 4 байта         */
        cmpl  $array_end, %ebx  /* сравнить адрес текущего элемента и 
                                   адрес конца массива               */
        je    loop_end          /* если они равны, выйти из цикла    */
        jmp   loop_start        /* иначе повторить цикл снова        */
loop_end:
 
/*
 * следующий код выводит число из %eax на экран и завершает программу
 */
        pushl %eax
        pushl $printf_format
        call  printf
        addl  $8, %esp
 
        movl  $0, %eax
        ret
